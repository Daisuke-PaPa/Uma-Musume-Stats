<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sleep & Power — Mini v6 (user-priority)</title>
<style>
  :root{
    --bg-dark:#041226;
    --card-dark:#062033;
    --text:#dfefff;
    --muted:#90b0d6;
    --accent:#2dd4bf;
    --on-bg:#fff7ed;
    --on-text:#0b1220;
  }
  html,body{height:100%;margin:0;font-family:system-ui,Roboto,Arial;background:var(--bg-dark);color:var(--text);}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:18px}
  .sheet{width:100%;max-width:520px;text-align:center}
  h1{margin:0 0 12px;font-size:20px}
  .card{background:var(--card-dark);padding:14px;border-radius:12px;margin-bottom:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  .row{display:flex;justify-content:center;gap:12px;align-items:center;flex-wrap:wrap}
  .muted{color:var(--muted);font-size:13px}
  .big{font-weight:800;font-size:18px}
  /* Toggle switch */
  .switch{
    --w:78px; --h:38px; --pad:4px;
    position:relative;width:var(--w);height:var(--h);display:inline-block;
  }
  .switch input{display:none}
  .track{
    position:absolute;inset:0;background:rgba(255,255,255,0.06);border-radius:999px;transition:background .18s, transform .18s;
    box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);
  }
  .knob{
    position:absolute;top:var(--pad);left:var(--pad);width:calc(var(--h) - var(--pad)*2);height:calc(var(--h) - var(--pad)*2);
    background:linear-gradient(180deg, #fff,#e6e6e6);border-radius:50%;box-shadow:0 6px 14px rgba(2,6,23,0.45);
    transition: transform .18s cubic-bezier(.2,.9,.3,1), left .18s;
    display:flex;align-items:center;justify-content:center;font-size:12px;color:#0b1220;font-weight:700;
  }
  .switch input:checked + .track{background:linear-gradient(90deg, #9ae6b4, #34d399);}
  .switch input:checked + .track + .knob{ transform: translateX(calc(var(--w) - var(--h))); }
  .label-under{font-size:13px;color:var(--muted);margin-top:8px}
  .btn {padding:8px 12px;border-radius:8px;border:0;background:#0f1724;color:#fff;font-weight:700}
  .modal-back{position:fixed;inset:0;background:rgba(3,6,12,0.6);display:none;align-items:center;justify-content:center;z-index:60}
  .modal{background:#071832;padding:14px;border-radius:10px;min-width:280px;max-width:520px}
  .modal h3{margin:0 0 8px}
  input[type=datetime-local]{padding:8px;border-radius:8px;border:0;background:#021220;color:var(--text);width:100%}
  .muted-small{font-size:12px;color:var(--muted)}
  /* theme when lights on */
  body.lights-on{background:var(--on-bg);color:var(--on-text)}
  body.lights-on .sheet .card{background:#fff9f2}
  body.lights-on .muted{color:#6d4a31}
  body.lights-on .knob{background:linear-gradient(180deg,#fff,#fff);color:var(--on-text)}
  body.lights-on .track{box-shadow:inset 0 1px 0 rgba(0,0,0,0.02)}
  @media (max-width:420px){ .switch{--w:68px;--h:34px} .big{font-size:16px} }
  .log {white-space:pre-wrap;font-size:13px;color:#cfe8ff;margin-top:8px;text-align:left}
</style>
</head>
<body>
  <div class="wrap">
    <div class="sheet">
      <h1>⚡ Sleep & Power — Mini v6</h1>

      <div class="card" id="powerCard">
        <div class="row" style="align-items:center">
          <label style="display:flex;flex-direction:column;align-items:center;gap:6px">
            <div style="font-size:13px;color:var(--muted)">Electricity</div>
            <div class="switch">
              <input id="powerToggle" type="checkbox" />
              <div class="track"></div>
              <div class="knob" id="powerKnob">OFF</div>
            </div>
          </label>

          <label style="display:flex;flex-direction:column;align-items:center;gap:6px">
            <div style="font-size:13px;color:var(--muted)">Sleep</div>
            <div class="switch">
              <input id="sleepToggle" type="checkbox" />
              <div class="track"></div>
              <div class="knob" id="sleepKnob">REST</div>
            </div>
          </label>
        </div>

        <div class="label-under muted" style="margin-top:10px">
          Last power: <span id="lastPower">—</span> &nbsp; | &nbsp; Last sleep: <span id="lastSleep">—</span>
        </div>
      </div>

      <div class="card">
        <div>Inferred routine: <span id="routine" class="big">Unknown</span> &nbsp; (<span id="conf">0%</span>)</div>
        <div style="margin-top:8px" class="muted">Next expected change: <span id="nextChange">—</span></div>
      </div>

      <div class="card">
        <div>Total sleep last 24h: <span id="sleep24" class="big">0 min</span></div>
        <div style="margin-top:6px" class="muted">Goal: 480 min (8 hr). Status: <span id="goalStatus">Not enough</span></div>
      </div>

      <div class="card muted" style="font-size:13px">
        Tip: Your taps now override simulated history. New inputs are saved as <b>user</b> events (weighted higher) so inference updates immediately.
      </div>

      <div style="text-align:center;margin-top:6px">
        <button id="showLog" class="btn">Show Log (debug)</button>
      </div>
      <div id="logOut" class="log" style="display:none"></div>

    </div>
  </div>

  <!-- calibration modal -->
  <div id="modalBack" class="modal-back">
    <div class="modal">
      <h3>Calibration — last power cutoff?</h3>
      <div class="muted-small">Enter when power last CUT OFF (resume optional). If you leave resume empty the app will auto-simulate forward to now and backfill your observed ON to the closest earlier routine ON time.</div>
      <div style="margin-top:10px">
        <div style="margin-bottom:8px">
          <label class="muted-small">Cutoff (OFF) time</label><br>
          <input id="cutoffInput" type="datetime-local" />
        </div>
        <div style="margin-bottom:8px">
          <label class="muted-small">Resume (ON) time — optional</label><br>
          <input id="resumeInput" type="datetime-local" />
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:6px">
          <button id="skipBtn" class="btn">Skip</button>
          <button id="saveCutoff" class="btn">Save</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* Storage keys */
const K = {P:'pwr_v6', S:'sleep_v6'};

/* Load */
let powerEvents = JSON.parse(localStorage.getItem(K.P) || '[]'); // newest first {ts,on,source}
let sleeps = JSON.parse(localStorage.getItem(K.S) || '[]');    // newest first {start,end,mins}

/* DOM */
const powerToggle = document.getElementById('powerToggle');
const sleepToggle = document.getElementById('sleepToggle');
const powerKnob = document.getElementById('powerKnob');
const sleepKnob = document.getElementById('sleepKnob');

const lastPowerEl = document.getElementById('lastPower');
const lastSleepEl = document.getElementById('lastSleep');
const routineEl = document.getElementById('routine');
const confEl = document.getElementById('conf');
const nextEl = document.getElementById('nextChange');
const sleep24El = document.getElementById('sleep24');
const goalStatusEl = document.getElementById('goalStatus');

const modalBack = document.getElementById('modalBack');
const cutoffInput = document.getElementById('cutoffInput');
const resumeInput = document.getElementById('resumeInput');
const saveCutoff = document.getElementById('saveCutoff');
const skipBtn = document.getElementById('skipBtn');

const showLogBtn = document.getElementById('showLog');
const logOut = document.getElementById('logOut');

let sleeping = false, curStart = null;
let pendingEvent = null;

/* Routine helpers (transition times are strict) */
const TRANS_TIMES = [ {h:5,m:0}, {h:9,m:0}, {h:13,m:0}, {h:17,m:0}, {h:21,m:0} ]; // daily transitions
function tMin(d){ return d.getHours()*60 + d.getMinutes(); }
function inRange(t,s,e){ if(s<=e) return t>=s && t<e; return t>=s || t<e; }
function expectedAt(r, date){
  const t = tMin(date);
  if(r==='C') return true;
  if(inRange(t,21*60,24*60) || inRange(t,0,5*60)) return true;
  if(r==='A'){
    if(inRange(t,5*60,9*60)) return false;
    if(inRange(t,9*60,13*60)) return true;
    if(inRange(t,13*60,17*60)) return false;
    if(inRange(t,17*60,21*60)) return true;
  } else if(r==='B'){
    if(inRange(t,5*60,9*60)) return true;
    if(inRange(t,9*60,13*60)) return false;
    if(inRange(t,13*60,17*60)) return true;
    if(inRange(t,17*60,21*60)) return false;
  }
  return false;
}

/* Save/load */
function saveAll(){ localStorage.setItem(K.P, JSON.stringify(powerEvents)); localStorage.setItem(K.S, JSON.stringify(sleeps)); }
function fmtISO(iso){ if(!iso) return '—'; return new Date(iso).toLocaleString(); }

/* Utils: produce exact transition Date objects for a given day */
function transitionsForDay(dayDate){
  const arr = [];
  const base = new Date(dayDate);
  base.setHours(0,0,0,0);
  TRANS_TIMES.forEach(t => {
    const d = new Date(base);
    d.setHours(t.h, t.m, 0, 0);
    arr.push(d);
  });
  return arr;
}

/* Given a routine and a window, build exact transitions (ascending) */
function buildExactSchedule(routine, fromISO, toDate){
  const start = new Date(fromISO);
  const end = new Date(toDate);
  const list = [];
  const startDay = new Date(start); startDay.setHours(0,0,0,0);
  const endDay = new Date(end); endDay.setHours(0,0,0,0);
  for(let day = new Date(startDay); day <= endDay; day.setDate(day.getDate()+1)){
    const tlist = transitionsForDay(day);
    tlist.forEach(tdate => {
      if(tdate > start && tdate <= end){
        const after = new Date(tdate.getTime() + 1000);
        const on = expectedAt(routine, after);
        list.push({ts: tdate.toISOString(), on});
      }
    });
  }
  list.sort((a,b)=> new Date(a.ts) - new Date(b.ts));
  return list;
}

/* Find last transition <= date for routine with desiredState (or any) */
function getLastTransitionAtOrBefore(routine, date, desiredState=null, lookbackDays=7){
  const dt = new Date(date);
  for(let d=0; d<=lookbackDays; d++){
    const day = new Date(dt); day.setDate(dt.getDate() - d); day.setHours(0,0,0,0);
    const tlist = transitionsForDay(day);
    for(let i = tlist.length-1; i>=0; i--){
      const tdate = tlist[i];
      if(tdate <= dt){
        const after = new Date(tdate.getTime() + 1000);
        const on = expectedAt(routine, after);
        if(desiredState === null || on === desiredState) return {ts:tdate.toISOString(), on, source:'sim'};
      }
    }
  }
  return null;
}

/* Render UI + theme */
function render(){
  const currentOn = powerEvents.length ? powerEvents[0].on : false;
  document.body.classList.toggle('lights-on', !!currentOn);

  powerKnob.textContent = currentOn ? 'ON' : 'OFF';
  sleepKnob.textContent = sleeping ? 'WAKE' : 'REST';

  powerToggle.checked = !!currentOn;
  sleepToggle.checked = !!sleeping;

  lastPowerEl.textContent = powerEvents.length ? `${fmtISO(powerEvents[0].ts)} — ${powerEvents[0].on ? 'ON':'OFF'} (${powerEvents[0].source||'?'})` : '—';
  lastSleepEl.textContent = sleeps.length ? `${fmtISO(sleeps[0].start)} → ${fmtISO(sleeps[0].end)} (${sleeps[0].mins}m)` : (sleeping ? `Sleeping since ${new Date(curStart).toLocaleString()}` : '—');

  const inf = infer();
  routineEl.textContent = inf.r || 'Unknown';
  confEl.textContent = `${inf.c}%`;

  const next = nextToggleFor(inf.r);
  nextEl.textContent = next ? `${next.state} at ${next.time.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}` : 'No change predicted soon';

  const s24 = sleepLast24();
  sleep24El.textContent = `${s24} min`;
  goalStatusEl.textContent = s24 >= 480 ? 'Good (>=8h)' : 'Not enough';
}

/* NEW: helper to create a user event (snapped or fallback) with source 'user' */
function pushUserEvent(tsISO, onState){
  powerEvents.unshift({ts: tsISO, on: !!onState, source: 'user'});
}

/* When user taps power: snap to exact transition if possible.
   If no recent routine, treat as calibration (observedAt). Normal taps create source:'user' events. */
function recordPower(on){
  const now = new Date();
  const isNight = inRange(tMin(now), 21*60, 5*60);
  const lastEvent = powerEvents[0] ? new Date(powerEvents[0].ts) : null;
  const gapTooBig = !lastEvent || (now - lastEvent) > (48*3600000);

  if(on && isNight && gapTooBig && powerEvents.length < 5){
    pendingEvent = {observedAt: now.toISOString(), on:true};
    showCalibrationModal();
    return;
  }

  const inf = infer();
  let usedTs = null;
  if(inf.r){
    const last = getLastTransitionAtOrBefore(inf.r, now, on, 7);
    if(last) usedTs = last.ts;
  } else {
    let candidate = null;
    ['A','B'].forEach(r => {
      const last = getLastTransitionAtOrBefore(r, now, on, 7);
      if(last && (!candidate || new Date(last.ts) > new Date(candidate.ts))) candidate = last;
    });
    if(candidate) usedTs = candidate.ts;
  }

  if(usedTs){
    pushUserEvent(usedTs, on);
  } else {
    const fallback = new Date();
    fallback.setSeconds(0,0);
    pushUserEvent(fallback.toISOString(), on);
  }

  // After pushing user event, ensure it overrides any sim events at same minute
  cleanupAndSave();
  render();
}

/* Show modal */
function showCalibrationModal(){
  const d = new Date();
  d.setDate(d.getDate()-1);
  d.setHours(9,0,0,0);
  cutoffInput.value = d.toISOString().slice(0,16);
  resumeInput.value = '';
  modalBack.style.display = 'flex';
}

/* Improved scoring: normalized match rate + pending weight + tolerance (unchanged) */
function scoreSimulation(simEvents, pending){
  if(simEvents.length === 0) return {score:0, matches:0, realCount:0, pendingMatch:false, matchRate:0};

  const simStart = new Date(simEvents[0].ts);
  const simEnd = new Date(simEvents[simEvents.length - 1].ts);

  const relevantReal = powerEvents.map(e=>({t:new Date(e.ts), on:e.on, source:e.source})).filter(e=> e.t >= simStart && e.t <= simEnd);

  let matches = 0;
  const TOL_MS = 5*60000;

  relevantReal.forEach(real => {
    let simBefore = null;
    for(let i = simEvents.length - 1; i >= 0; i--){
      const sT = new Date(simEvents[i].ts);
      if(sT <= new Date(real.t.getTime() + TOL_MS)){
        simBefore = simEvents[i];
        break;
      }
    }
    const simState = simBefore ? simBefore.on : simEvents[0].on;
    if(simState === real.on) matches++;
  });

  const realCount = Math.max(1, relevantReal.length);
  const matchRate = matches / realCount;

  let pendingMatch = false;
  if(pending && pending.observedAt){
    const observed = new Date(pending.observedAt);
    const TOL_MS = 5*60000;
    let simBefore = null;
    for(let i = simEvents.length - 1; i >= 0; i--){
      const sT = new Date(simEvents[i].ts);
      if(sT <= new Date(observed.getTime() + TOL_MS)){
        simBefore = simEvents[i];
        break;
      }
    }
    const simState = simBefore ? simBefore.on : simEvents[0].on;
    pendingMatch = (simState === pending.on);
  } else if(pending && pending.on !== undefined){
    const finalState = simEvents[simEvents.length - 1].on;
    pendingMatch = (finalState === pending.on);
  }

  const brevity = Math.max(0, 1 - simEvents.length / 200);
  const SCORE = (matchRate * 0.7) + (pendingMatch ? 0.25 : 0) + (brevity * 0.05);

  return { score: SCORE, matches, realCount, pendingMatch, matchRate };
}

/* save handler for modal (exact transitions, but mark sources: 'sim' and observed markers as 'observed') */
saveCutoff.addEventListener('click', ()=>{
  const cutoffVal = cutoffInput.value;
  const resumeVal = resumeInput.value;
  if(!cutoffVal){ alert('Pick a cutoff date/time or press Skip'); return; }
  const offTs = new Date(cutoffVal).toISOString();
  powerEvents.unshift({ts: offTs, on:false, source:'user'}); // cutoff is a user-provided OFF

  if(resumeVal){
    const onTsRaw = new Date(resumeVal);
    const inf = infer();
    let snapped = null;
    if(inf.r){
      const last = getLastTransitionAtOrBefore(inf.r, onTsRaw, true, 3);
      if(last) snapped = last.ts;
    }
    if(!snapped){
      let cand = null;
      ['A','B'].forEach(r=>{
        const l = getLastTransitionAtOrBefore(r, onTsRaw, true, 3);
        if(l && (!cand || new Date(l.ts) > new Date(cand.ts))) cand = l;
      });
      if(cand) snapped = cand.ts;
    }
    const useTs = snapped || (new Date(onTsRaw).setSeconds(0,0) && new Date(onTsRaw).toISOString());
    powerEvents.unshift({ts: useTs, on:true, source:'user'});
    if(pendingEvent){
      if(pendingEvent.observedAt) powerEvents.push({ts: pendingEvent.observedAt, on: pendingEvent.on, source:'observed'});
      else powerEvents.unshift({ts: new Date().toISOString(), on: pendingEvent.on, source:'user'});
    }
  } else {
    const now = new Date();
    const simA = buildExactSchedule('A', offTs, now);
    const simB = buildExactSchedule('B', offTs, now);
    // tag sim events with source:'sim'
    const simAtag = simA.map(e=>({ts:e.ts,on:e.on,source:'sim'}));
    const simBtag = simB.map(e=>({ts:e.ts,on:e.on,source:'sim'}));
    const scA = scoreSimulation(simA, pendingEvent);
    const scB = scoreSimulation(simB, pendingEvent);

    const MIN_CONF = 0.50;
    const MIN_MARGIN = 0.07;
    const chosenObj = (scB.score > scA.score) ? {sim:simBtag, name:'B', scoreObj:scB} : {sim:simAtag, name:'A', scoreObj:scA};
    const otherObj = (chosenObj.name === 'A') ? scB : scA;

    if(chosenObj.scoreObj.score >= MIN_CONF && (chosenObj.scoreObj.score - otherObj.score) >= MIN_MARGIN){
      const simEvents = chosenObj.sim.slice(); // array of {ts,on,source:'sim'}
      if(pendingEvent && pendingEvent.observedAt){
        const observed = new Date(pendingEvent.observedAt);
        let foundSimOn = null;
        for(let i = simEvents.length-1; i>=0; i--){
          const se = simEvents[i];
          if(se.on && new Date(se.ts) <= observed){
            foundSimOn = se;
            break;
          }
        }
        if(!foundSimOn){
          simEvents.push({ts: pendingEvent.observedAt, on:true, source:'observed'});
        } else {
          // nothing extra; simulated ON already covers resumed state
        }
      } else if(pendingEvent){
        simEvents.push({ts: new Date().toISOString(), on: pendingEvent.on, source:'observed'});
      }
      powerEvents = powerEvents.concat(simEvents);
    } else {
      if(pendingEvent){
        if(pendingEvent.observedAt){
          // snap observed to nearest earlier transition if possible and mark 'observed'
          let snapped = null;
          ['A','B'].forEach(r=>{
            const found = getLastTransitionAtOrBefore(r, new Date(pendingEvent.observedAt), pendingEvent.on, 3);
            if(found && (!snapped || new Date(found.ts) > new Date(snapped))) snapped = found.ts;
          });
          if(snapped) powerEvents.push({ts: snapped, on: pendingEvent.on, source:'observed'});
          else powerEvents.push({ts: pendingEvent.observedAt, on: pendingEvent.on, source:'observed'});
        } else {
          powerEvents.unshift({ts: new Date().toISOString(), on: pendingEvent.on, source:'observed'});
        }
      }
    }
  }

  cleanupAndSave();
  pendingEvent = null;
  modalBack.style.display = 'none';
  render();
});

/* Skip handler */
skipBtn.addEventListener('click', ()=>{
  if(pendingEvent){
    if(pendingEvent.observedAt){
      let snapped = null;
      ['A','B'].forEach(r=>{
        const found = getLastTransitionAtOrBefore(r, new Date(pendingEvent.observedAt), pendingEvent.on, 3);
        if(found && (!snapped || new Date(found.ts) > new Date(snapped))) snapped = found.ts;
      });
      if(snapped) powerEvents.push({ts: snapped, on: pendingEvent.on, source:'observed'});
      else powerEvents.push({ts: pendingEvent.observedAt, on: pendingEvent.on, source:'observed'});
    } else {
      powerEvents.unshift({ts: new Date().toISOString(), on: pendingEvent.on, source:'observed'});
    }
  }
  pendingEvent = null;
  cleanupAndSave();
  modalBack.style.display = 'none';
  render();
});

/* Sleep toggle logic */
function toggleSleep(){
  if(!sleeping){
    sleeping = true;
    curStart = new Date().toISOString();
  } else {
    sleeping = false;
    const end = new Date().toISOString();
    const mins = Math.round((new Date(end) - new Date(curStart))/60000);
    sleeps.unshift({start: curStart, end, mins});
    if(sleeps.length>500) sleeps.length=500;
    curStart = null;
    saveAll();
  }
  render();
}
powerToggle.addEventListener('change', ()=>{ recordPower(powerToggle.checked); });
sleepToggle.addEventListener('change', ()=>{ toggleSleep(); });

/* Inference: weighted by source
   weights: user=3, observed=2, sim=1
*/
function infer(){
  if(powerEvents.length === 0) return {r:null,c:0};
  const N = Math.min(80, powerEvents.length); // consider more events but weighted
  const slice = powerEvents.slice(0,N);
  let scores = {A:0,B:0,C:0};
  let totalWeight = 0;
  slice.forEach(e=>{
    const d = new Date(e.ts);
    const src = e.source || 'sim';
    const w = (src === 'user') ? 3 : (src === 'observed' ? 2 : 1);
    totalWeight += w;
    if(expectedAt('A',d) === e.on) scores.A += w;
    if(expectedAt('B',d) === e.on) scores.B += w;
    if(expectedAt('C',d) === e.on) scores.C += w;
  });
  const confA = Math.round(100 * (scores.A / Math.max(1,totalWeight)));
  const confB = Math.round(100 * (scores.B / Math.max(1,totalWeight)));
  const confC = Math.round(100 * (scores.C / Math.max(1,totalWeight)));
  let best='A', bestVal = confA;
  if(confB > bestVal){ best='B'; bestVal=confB; }
  if(confC > bestVal){ best='C'; bestVal=confC; }
  return {r: bestVal >= 55 ? best : null, c: bestVal};
}

/* next predicted toggle based on exact schedule */
function nextToggleFor(r){
  const now = new Date();
  if(!r) r='A';
  const candidates = [];
  for(let i=0;i<3;i++){
    const day = new Date(); day.setDate(day.getDate()+i); day.setHours(0,0,0,0);
    transitionsForDay(day).forEach(t => {
      if(t > now){
        const after = new Date(t.getTime() + 1000);
        const on = expectedAt(r, after);
        candidates.push({time:t, state:on});
      }
    });
  }
  candidates.sort((a,b)=>a.time - b.time);
  return candidates.length ? {time:candidates[0].time, state: candidates[0].state ? 'ON' : 'OFF'} : null;
}

function sleepLast24(){
  const cutoff = new Date(Date.now() - 24*3600000);
  let total=0;
  sleeps.forEach(s=>{
    const st=new Date(s.start), en=new Date(s.end);
    if(en <= cutoff) return;
    const start = st < cutoff ? cutoff : st;
    const end = en;
    total += Math.max(0, Math.round((end-start)/60000));
  });
  if(sleeping && curStart){
    const st = new Date(curStart);
    const start = st < cutoff ? cutoff : st;
    const end = new Date();
    if(end>start) total += Math.round((end-start)/60000);
  }
  return total;
}

/* Dedupe and prefer user/observed over sim, collapse near-duplicates */
function cleanupAndSave(){
  // sort newest-first
  powerEvents.sort((a,b)=> new Date(b.ts) - new Date(a.ts));
  const cleaned = [];
  for(let i=0;i<powerEvents.length;i++){
    const cur = powerEvents[i];
    if(cleaned.length === 0){ cleaned.push(cur); continue; }
    const prev = cleaned[cleaned.length-1];

    // exact duplicate timestamp and state
    if(prev.ts === cur.ts && prev.on === cur.on){
      // prefer higher-priority source: user > observed > sim
      const priority = s => (s === 'user')?3 : (s==='observed'?2:1);
      if(priority(cur.source) > priority(prev.source)){
        // replace prev with cur (cur is newer in iteration? prev is newer-first, but cur might be user)
        cleaned[cleaned.length-1] = cur;
      }
      // else keep prev and drop cur
      continue;
    }

    const prevDate = new Date(prev.ts), curDate = new Date(cur.ts);
    if(Math.abs(prevDate - curDate) <= 60000 && prev.on === cur.on){
      // same minute and same state -> prefer event with higher source priority
      const priority = s => (s === 'user')?3 : (s==='observed'?2:1);
      if(priority(cur.source) > priority(prev.source)){
        cleaned[cleaned.length-1] = cur;
      }
      continue;
    }

    cleaned.push(cur);
  }
  powerEvents = cleaned;
  // trim
  if(powerEvents.length>1500) powerEvents.length=1500;
  saveAll();
}

/* Debug / log */
showLogBtn.addEventListener('click', ()=>{
  const p = JSON.parse(localStorage.getItem(K.P) || '[]');
  const s = JSON.parse(localStorage.getItem(K.S) || '[]');
  const inf = infer();
  const lines = [];
  lines.push('Now: ' + new Date().toLocaleString());
  lines.push('Inferred: ' + (inf.r||'Unknown') + '  (conf ' + inf.c + '%)');
  lines.push('');
  lines.push('Recent power events (newest first):');
  p.slice(0,40).forEach(e => lines.push(` ${new Date(e.ts).toLocaleString()} — ${e.on?'ON':'OFF'} [${e.source||'sim'}]`));
  const lastOff = p.slice().reverse().find(x => x.on === false);
  if(lastOff){
    lines.push('');
    lines.push('Last OFF used for sim: ' + new Date(lastOff.ts).toLocaleString());
    const simA = buildExactSchedule('A', lastOff.ts, new Date());
    const simB = buildExactSchedule('B', lastOff.ts, new Date());
    const scA = scoreSimulation(simA, pendingEvent);
    const scB = scoreSimulation(simB, pendingEvent);
    lines.push('Sim A -> events: ' + simA.map(e=>`${new Date(e.ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}:${e.on?'ON':'OFF'}`).join(' | '));
    lines.push(`Score A: ${scA.score.toFixed(3)} (matches ${scA.matches}/${scA.realCount}) pendingMatch:${scA.pendingMatch}`);
    lines.push('Sim B -> events: ' + simB.map(e=>`${new Date(e.ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}:${e.on?'ON':'OFF'}`).join(' | '));
    lines.push(`Score B: ${scB.score.toFixed(3)} (matches ${scB.matches}/${scB.realCount}) pendingMatch:${scB.pendingMatch}`);
  }
  logOut.style.display = 'block';
  logOut.textContent = lines.join('\n');
});

/* Init */
cleanupAndSave();
render();
setInterval(render,15000);
</script>
</body>
</html>
